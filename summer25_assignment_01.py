# -*- coding: utf-8 -*-
"""Summer2025_Assignment-01

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18az-qpSq7w6osNYuZNdiYtMbU-pt7gwk

Assingment 1

Part-1
"""

import heapq
def heuristic(a, b): #(h) in A*
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

def a_star_search(maze, go, finish, n, m):
    #2_3_3_0_1_6_8_0
    opnlst = [(0, go)]
    heapq.heapify(opnlst)
    cfrem = {}
    gsore = { (r, c): float('inf') for r in range(n) for c in range(m) }
    gsore[go] = 0 #cost from start to the current
    fsore = { (r, c): float('inf') for r in range(n) for c in range(m) }
    fsore[go] = heuristic(go, finish) #(gsore + heuristic)
    while opnlst:
        curant = heapq.heappop(opnlst)[1] #finding lowest fsore nd returning path
        if curant == finish:
            path = []
            while curant in cfrem:
                path.append(curant)
                curant = cfrem[curant]
            path.append(go)
            path.reverse()
            return path

        row, col = curant
        vicinity = [(row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1)] #Up, Down, Left, Right
        #ID:23301680
        for neigh in vicinity:
            nrow, ncol = neigh
            if 0 <= nrow < n and 0 <= ncol < m and maze[nrow][ncol] == '0': #Is neighbour valid?
                tentivegsore = gsore[curant] + 1 #always 1
                # If better, record it
                if tentivegsore < gsore[neigh]:
                    cfrem[neigh] = curant
                    gsore[neigh] = tentivegsore
                    fsore[neigh] = tentivegsore + heuristic(neigh, finish)
                    # If not, add it
                    if (fsore[neigh], neigh) not in opnlst:
                         heapq.heappush(opnlst, (fsore[neigh], neigh))
                         #23301680
    return None

def get_move_sequence(path):
    if not path or len(path) <= 1:
        return ""
    moves = []
    for i in range(len(path) - 1):
        y1, x1 = path[i]
        y2, x2 = path[i+1]
        if y2 < y1:
            moves.append('U') # Up
        elif y2 > y1:
            moves.append('D') # Down
        elif x2 < x1:
            moves.append('L') # Left
        elif x2 > x1:
            moves.append('R') # Right
    return "".join(moves)


def main():
    try:
        n, m = map(int, input().split())
        start_y, start_x = map(int, input().split())
        end_y, end_x = map(int, input().split())
        maze = [input() for _ in range(n)]
        start_node = (start_y, start_x)
        end_node = (end_y, end_x)
        if maze[start_y][start_x] == '#' or maze[end_y][end_x] == '#':
             print(-1)
             return

        path = a_star_search(maze, start_node, end_node, n, m)
        if path:
            moves = get_move_sequence(path)
            print(len(moves))
            print(moves)
        else:
            print(-1)
    except (ValueError, IndexError):
        print("Wrong input format")
main()

"""Part-2"""

from collections import deque
def bfs(graf, gonode, finalnode):
    if gonode == finalnode:
        return 0
    queue = deque([(gonode, 0)])
    # queue to avoid cycles and redundant work
    went = {gonode}

    while queue:
        carantnode, dist = queue.popleft()
        if carantnode in graf:
            for neighbor in graf[carantnode]:
                if neighbor == finalnode:
                    return dist + 1

                if neighbor not in went:
                    went.add(neighbor)
                    queue.append((neighbor, dist + 1))
    return float('inf') #if not reachable

def main():
    try:
        n, m = map(int, input().split())
        gonode, finalnode = map(int, input().split())

        heuristics = {}
        for _ in range(n):
            node, hval = map(int, input().split())
            heuristics[node] = hval

        graf = {}
        for _ in range(m):
            u, v = map(int, input().split())
            # adding edges
            graf.setdefault(u, []).append(v)
            graf.setdefault(v, []).append(u)

        inadmissiblenodes = []
        for node in range(1, n + 1):
            heuristic_value = heuristics[node]# h*(n)
            truecost = bfs(graf, node, finalnode)
            if heuristic_value > truecost:
                inadmissiblenodes.append(node)

        if not inadmissiblenodes:
            print(1)
        else:
            print(0)
            inadmissiblenodes.sort()
            nodes_str = ", ".join(map(str, inadmissiblenodes))
            print(f"Here nodes {nodes_str} are inadmissible.")

    except (ValueError, KeyError, IndexError) as e:
        print(f"Wrong input format. Error: {e}")


main()
