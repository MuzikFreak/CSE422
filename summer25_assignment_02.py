# -*- coding: utf-8 -*-
"""summer25_assignment_02

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Gyj9x-H-nrDQjLeBpU3w2XMlqDG8fzXt
"""

import random
import math
WIDTH = 25
HEIGHT = 25
COMPOz = {
    "ALU": {"width": 5, "height": 5},
    "Cache": {"width": 7, "height": 4},
    "Control Unit": {"width": 4, "height": 4},
    "Register File": {"width": 6, "height": 6},
    "Decoder": {"width": 5, "height": 3},
    "Floating Unit": {"width": 5, "height": 5},
}
COMPON3NTNAMEz = list(COMPOz.keys())
COMPODIMz = [
    (COMPOz[name]["width"], COMPOz[name]["height"]) for name in COMPON3NTNAMEz
]
NUMCOMPOz = len(COMPON3NTNAMEz)
CONNECTIONz = [
    (3, 0),
    (2, 0),
    (0, 1),
    (3, 5),
    (1, 4),
    (4, 5),
]
POPUSIZe = 6
MAXGENz = 15
MUTATONRAT3 = 0.10
ELITIzMOUNT = 1
TOURzIZE = 3
CROSSTYPE = "two_point"

aplha = 1000
beta = 2
gamma = 1
class FloorPlanGA:
    def __init__(self):
        self.PoPution = []
        self.BestZolutionSoFar = None
    def Individual(self):
        Chrome = []
        for i in range(NUMCOMPOz):
            width, height = COMPODIMz[i]
            maxX = WIDTH - width
            maxY = HEIGHT - height
            x = random.randint(0, maxX)
            y = random.randint(0, maxY)
            Chrome.append((x, y))
        return tuple(Chrome)
    def initialpopu(self):
        self.PoPution = [self.Individual() for _ in range(POPUSIZe)]
    def calCfitness(self, Chrome):
        overlap = self.calCoverlap(Chrome)
        wiringleng = self.calCwiringdis(Chrome)
        bounding = self.calCboundbox(Chrome)
        fitness = -((aplha * overlap) + (beta * wiringleng) + (gamma * bounding))
        return fitness, overlap, wiringleng, bounding
    def calCoverlap(self, Chrome):
        overlapcount = 0 #23301680
        for i in range(NUMCOMPOz):
            for j in range(i + 1, NUMCOMPOz):
                x1, y1 = Chrome[i]
                w1, h1 = COMPODIMz[i]
                r1 = x1 + w1
                t1 = y1 + h1
                x2, y2 = Chrome[j]
                w2, h2 = COMPODIMz[j]
                r2 = x2 + w2
                t2 = y2 + h2
                if not (r1 <= x2 or x1 >= r2 or t1 <= y2 or y1 >= t2):
                    overlapcount += 1
        return overlapcount
    def calCwiringdis(self, Chrome):
        totdist = 0
        for i, j in CONNECTIONz:
            x1, y1 = Chrome[i]
            w1, h1 = COMPODIMz[i]
            center1_x, center1_y = x1 + w1 / 2, y1 + h1 / 2
            x2, y2 = Chrome[j]
            w2, h2 = COMPODIMz[j]
            center2_x, center2_y = x2 + w2 / 2, y2 + h2 / 2
            distance = math.sqrt((center1_x - center2_x)**2 + (center1_y - center2_y)**2)
            totdist += distance
        return totdist
    def calCboundbox(self, Chrome):
        if not Chrome:
            return 0
        minX = float('inf')
        minY = float('inf')
        maxR = float('-inf')
        maxT = float('-inf')
        for i in range(NUMCOMPOz):
            x, y = Chrome[i]
            w, h = COMPODIMz[i]
            minX = min(minX, x)
            minY = min(minY, y)
            maxR = max(maxR, x + w)
            maxT = max(maxT, y + h)
        return (maxR - minX) * (maxT - minY)
    def selection(self, evaluatedpopu):
        tourconts = random.sample(evaluatedpopu, TOURzIZE)
        tourconts.sort(key=lambda x: x[0], reverse=True)
        return tourconts[0][4]
    def crossover(self, parent1, parent2):
        if CROSSTYPE == 'single_point':
            point = random.randint(1, NUMCOMPOz - 1)
            child1 = parent1[:point] + parent2[point:]
            child2 = parent2[:point] + parent1[point:]
        elif CROSSTYPE == 'two_point':
            point1 = random.randint(1, NUMCOMPOz - 2)
            point2 = random.randint(point1 + 1, NUMCOMPOz - 1)
            child1 = parent1[:point1] + tuple(list(parent2)[point1:point2]) + parent1[point2:]
            child2 = parent2[:point1] + tuple(list(parent1)[point1:point2]) + parent2[point2:]
        else:
            point = random.randint(1, NUMCOMPOz - 1)
            child1 = parent1[:point] + parent2[point:]
            child2 = parent2[:point] + parent1[point:]
        return child1, child2
    def mutate(self, Chrome):
        if random.random() < MUTATONRAT3:
            geneidx = random.randint(0, NUMCOMPOz - 1)
            width, height = COMPODIMz[geneidx]
            maxX = WIDTH - width
            maxY = HEIGHT - height
            newX = random.randint(0, maxX)
            newY = random.randint(0, maxY)
            mutatedchromo = list(Chrome)
            mutatedchromo[geneidx] = (newX, newY)
            return tuple(mutatedchromo)
        return Chrome
    def run(self):
        print("Starting Genetic Algorithm for VLSI Floorplanning")
        self.initialpopu()
        for gen in range(MAXGENz):
            evaluatedpopu = []
            for chrom in self.PoPution:
                fitness, overlap, wire, area = self.calCfitness(chrom)
                evaluatedpopu.append((fitness, overlap, wire, area, chrom))
            evaluatedpopu.sort(key=lambda x: x[0], reverse=True)
            currTbest = evaluatedpopu[0]
            if self.BestZolutionSoFar is None or currTbest[0] > self.BestZolutionSoFar[0]:
                self.BestZolutionSoFar = currTbest
            print(f"Generation {gen + 1}/{MAXGENz} | "
                  f"Best Fitness: {currTbest[0]:.2f} | "
                  f"Overlap: {currTbest[1]} | "
                  f"Wiring: {currTbest[2]:.2f} | "
                  f"Area: {currTbest[3]}")
            nextpopu = []
            for i in range(ELITIzMOUNT):
                nextpopu.append(evaluatedpopu[i][4])
            while len(nextpopu) < POPUSIZe:
                parent1 = self.selection(evaluatedpopu)
                parent2 = self.selection(evaluatedpopu)
                child1, child2 = self.crossover(parent1, parent2)
                child1 = self.mutate(child1)
                child2 = self.mutate(child2)
                nextpopu.append(child1)
                if len(nextpopu) < POPUSIZe:
                    nextpopu.append(child2)
            self.PoPution = nextpopu
        self.print_final_results()
    def print_final_results(self):
        print("Genetic Algorithm Finished")
        if self.BestZolutionSoFar:
            fitness, overlap, wire, area, chrom = self.BestZolutionSoFar
            print(f"Best Fitness Value Found: {fitness:.2f}")
            print(f"Corresponding Overlap Count: {overlap}")
            print(f"Corresponding Total Wiring Length: {wire:.2f}")
            print(f"Corresponding Bounding Box Area: {area}")
            print("\nOptimal Placement (Bottom-Left Coordinates):")
            for i in range(NUMCOMPOz):
                print(f"  - {COMPON3NTNAMEz[i]:<15}: {chrom[i]}")
        else:
            print("No solution was found.")
gasolver = FloorPlanGA()
gasolver.run()

import random
import math

GRIDWIDTH = 25
GRIDHEIGHT = 25

COMPONENTS = {
    "ALU": {"width": 5, "height": 5},
    "Cache": {"width": 7, "height": 4},
    "Control Unit": {"width": 4, "height": 4},
    "Register File": {"width": 6, "height": 6},
    "Decoder": {"width": 5, "height": 3},
    "Floating Unit": {"width": 5, "height": 5},
}
COMPONENTNAMES = list(COMPONENTS.keys())
COMPONENTDIMS = [
    (COMPONENTS[name]["width"], COMPONENTS[name]["height"]) for name in COMPONENTNAMES
]
NUMCOMPONENTz = len(COMPONENTNAMES)

CONNECTIONz = [
    (3, 0),
    (2, 0),
    (0, 1),
    (3, 5),
    (1, 4),
    (4, 5),
]

POPULaTIONSIZe = 6
MAXGEN3RATIONz = 15
MUTATION_RATE = 0.10
ELITISM_COUNT = 1
TOURNAMENT_SIZE = 3
CROSSOVER_TYPE = "two_point"

ALPHA = 1000
BETA = 2
GAMMA = 1


class FloorplanGA:
    def __init__(self):
        self.population = []
        self.best_solution_so_far = None

    def create_individual(self):
        chromosome = []
        for i in range(NUMCOMPONENTz):
            width, height = COMPONENTDIMS[i]
            max_x = GRIDWIDTH - width
            max_y = GRIDHEIGHT - height
            x = random.randint(0, max_x)
            y = random.randint(0, max_y)
            chromosome.append((x, y))
        return tuple(chromosome)

    def create_initial_population(self):
        self.population = [self.create_individual() for _ in range(POPULaTIONSIZe)]

    def calculate_fitness(self, chromosome):
        overlap = self._calculate_overlap(chromosome)
        wiring_length = self._calculate_wiring_distance(chromosome)
        bounding_area = self._calculate_bounding_box_area(chromosome)
        fitness_score = -((ALPHA * overlap) + (BETA * wiring_length) + (GAMMA * bounding_area))
        return fitness_score, overlap, wiring_length, bounding_area

    def _calculate_overlap(self, chromosome):
        overlap_count = 0
        for i in range(NUMCOMPONENTz):
            for j in range(i + 1, NUMCOMPONENTz):
                x1, y1 = chromosome[i]
                w1, h1 = COMPONENTDIMS[i]
                r1 = x1 + w1
                t1 = y1 + h1

                x2, y2 = chromosome[j]
                w2, h2 = COMPONENTDIMS[j]
                r2 = x2 + w2
                t2 = y2 + h2

                if not (r1 <= x2 or x1 >= r2 or t1 <= y2 or y1 >= t2):
                    overlap_count += 1
        return overlap_count

    def _calculate_wiring_distance(self, chromosome):
        total_distance = 0
        for i, j in CONNECTIONz:
            x1, y1 = chromosome[i]
            w1, h1 = COMPONENTDIMS[i]
            center1_x, center1_y = x1 + w1 / 2, y1 + h1 / 2

            x2, y2 = chromosome[j]
            w2, h2 = COMPONENTDIMS[j]
            center2_x, center2_y = x2 + w2 / 2, y2 + h2 / 2

            distance = math.sqrt((center1_x - center2_x)**2 + (center1_y - center2_y)**2)
            total_distance += distance
        return total_distance

    def _calculate_bounding_box_area(self, chromosome):
        if not chromosome:
            return 0

        min_x = float('inf')
        min_y = float('inf')
        max_r = float('-inf')
        max_t = float('-inf')

        for i in range(NUMCOMPONENTz):
            x, y = chromosome[i]
            w, h = COMPONENTDIMS[i]
            min_x = min(min_x, x)
            min_y = min(min_y, y)
            max_r = max(max_r, x + w)
            max_t = max(max_t, y + h)

        return (max_r - min_x) * (max_t - min_y)

    def selection(self, evaluated_population):
        tournament_contenders = random.sample(evaluated_population, TOURNAMENT_SIZE)
        tournament_contenders.sort(key=lambda x: x[0], reverse=True)
        return tournament_contenders[0][4]

    def crossover(self, parent1, parent2):
        if CROSSOVER_TYPE == 'single_point':
            point = random.randint(1, NUMCOMPONENTz - 1)
            child1 = parent1[:point] + parent2[point:]
            child2 = parent2[:point] + parent1[point:]
        elif CROSSOVER_TYPE == 'two_point':
            point1 = random.randint(1, NUMCOMPONENTz - 2)
            point2 = random.randint(point1 + 1, NUMCOMPONENTz - 1)
            child1 = parent1[:point1] + tuple(list(parent2)[point1:point2]) + parent1[point2:]
            child2 = parent2[:point1] + tuple(list(parent1)[point1:point2]) + parent2[point2:]
        else:
            point = random.randint(1, NUMCOMPONENTz - 1)
            child1 = parent1[:point] + parent2[point:]
            child2 = parent2[:point] + parent1[point:]

        return child1, child2

    def mutate(self, chromosome):
        if random.random() < MUTATION_RATE:
            gene_idx = random.randint(0, NUMCOMPONENTz - 1)
            width, height = COMPONENTDIMS[gene_idx]
            max_x = GRIDWIDTH - width
            max_y = GRIDHEIGHT - height
            new_x = random.randint(0, max_x)
            new_y = random.randint(0, max_y)
            mutated_chromosome = list(chromosome)
            mutated_chromosome[gene_idx] = (new_x, new_y)
            return tuple(mutated_chromosome)
        return chromosome

    def run(self):
        print("Starting Genetic Algorithm for VLSI Floorplanning")
        self.create_initial_population()

        for gen in range(MAXGEN3RATIONz):
            evaluated_population = []
            for chrom in self.population:
                fitness, overlap, wire, area = self.calculate_fitness(chrom)
                evaluated_population.append((fitness, overlap, wire, area, chrom))

            evaluated_population.sort(key=lambda x: x[0], reverse=True)

            current_best = evaluated_population[0]
            if self.best_solution_so_far is None or current_best[0] > self.best_solution_so_far[0]:
                self.best_solution_so_far = current_best

            print(f"Generation {gen + 1}/{MAXGEN3RATIONz} | "
                  f"Best Fitness: {current_best[0]:.2f} | "
                  f"Overlap: {current_best[1]} | "
                  f"Wiring: {current_best[2]:.2f} | "
                  f"Area: {current_best[3]}")

            next_population = []

            for i in range(ELITISM_COUNT):
                next_population.append(evaluated_population[i][4])

            while len(next_population) < POPULaTIONSIZe:
                parent1 = self.selection(evaluated_population)
                parent2 = self.selection(evaluated_population)
                child1, child2 = self.crossover(parent1, parent2)
                child1 = self.mutate(child1)
                child2 = self.mutate(child2)
                next_population.append(child1)
                if len(next_population) < POPULaTIONSIZe:
                    next_population.append(child2)

            self.population = next_population

        self.print_final_results()

    def print_final_results(self):
        print("Genetic Algorithm Finished")
        if self.best_solution_so_far:
            fitness, overlap, wire, area, chrom = self.best_solution_so_far
            print(f"Best Fitness Value Found: {fitness:.2f}")
            print(f"Corresponding Overlap Count: {overlap}")
            print(f"Corresponding Total Wiring Length: {wire:.2f}")
            print(f"Corresponding Bounding Box Area: {area}")
            print("\nOptimal Placement (Bottom-Left Coordinates):")
            for i in range(NUMCOMPONENTz):
                print(f"  - {COMPONENTNAMES[i]:<15}: {chrom[i]}")
        else:
            print("No solution was found.")


ga_solver = FloorplanGA()
ga_solver.run()

